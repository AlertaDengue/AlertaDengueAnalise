Relatorio Semanal do Projeto Alerta Dengue para a cidade do Rio de Janeiro
===========================================================

```{r echo=FALSE}
source("../fun/Rt.r")
source("../fun/data2SE.r")
source("../fun/corrigecasos.r")
```


```{r echo=FALSE}
hoje <- Sys.Date()
SEhoje <- data2SE(hoje,file="../tabelas/SE.csv",format="%Y-%m-%d")
```

**Rio de Janeiro, `r as.character(hoje)`  (SE `r as.character(SEhoje)`)**

```{r echo=FALSE}
# Abre os dados mais recentes
dadosAPS <- paste("../",dadosAPS,sep="")
d<-read.csv(dadosAPS)
d<-subset(d,SE>=201001)

# corrige casos
listaAPS<-unique(d$APS)
for(i in 1:10) d$casosm[d$APS==listaAPS[i]] <-corrigecasos(d$casos[d$APS==listaAPS[i]])
```

Dengue a nivel da cidade
-----------------------

```{r echo=FALSE}
# identificando a ultima semana com casos
dc <- d[d$APS=="AP1",c("SE","casos")]
dc <-na.omit(dc)
uSE <- max(dc$SE)
```

Dados das ultimas 12 semanas:

```{r echo=FALSE}
# serie temporal de casos agregados na cidade
casos <- aggregate(d[,"casos"],by=list(SE=d$SE),FUN=sum) # casos brutos
casosm <- aggregate(d[,"casosm"],by=list(SE=d$SE),FUN=sum) # casos corrigidos
cidade<- merge(casos,casosm,by="SE")
names(cidade)<-c("SE","casos","casos_corrigidos")
dt<-subset(d,APS=="AP1")[,c("SE","tweets")]  #tweets
dc <- aggregate(d[,"tempmin"],by=list(SE=d$SE),FUN=mean,na.rm=TRUE) #clima
names(dc)[2]<-"tempmin"
cidade<- merge(cidade,dt,by="SE")
cidade<- merge(cidade,dc,by="SE")
tail(cidade,n=12)
```

Legenda:

- SE: semana epidemiologica
- casos: numero de casos de dengue no SINAN
- casos_corrigidos: estimativa do numero de casos notificados (1)
- tweets: numero de tweets relatando sintomas de dengue (2)
- tempmin: media das temperaturas minimas da semana


```{r echo=FALSE}
cidade <- subset(cidade,SE>=201101)
par(mfrow=c(1,1),mar=c(4,4,1,1))
plot(cidade$tweets,type="l",ylab="tweets",axes=FALSE,xlab="",main="Tweets sobre dengue")
axis(2)
le=dim(cidade)[1]
axis(1,at=rev(seq(le,1,by=-12)),labels=d$SE[rev(seq(le,1,by=-12))],las=2)
```


```{r echo=FALSE}
plot(cidade$casos, type="l", xlab="",ylab="casos notificados no MRJ",axes=FALSE,main="casos de dengue")
#lines(cidade$casos_corrigidos, col=2)
#legend((len-12),max(cidade$casos_corrigidos[(len-22):(len)],na.rm=TRUE),c("digitado","notificado estimado"),lty=1,col=1:2)
axis(2)
axis(1,at=rev(seq(le,1,by=-12)),labels=d$SE[rev(seq(le,1,by=-12))],las=2)
```

```{r echo=FALSE}
par(mfrow=c(1,1),mar=c(4,4,1,1))
plot(cidade$tempmin,type="l",ylab="temperatura",axes=FALSE,xlab="",main="Temperatura mínima")
axis(2)
le=dim(cidade)[1]
axis(1,at=rev(seq(le,1,by=-12)),labels=d$SE[rev(seq(le,1,by=-12))],las=2)
```



```{r echo=FALSE,results='hide'}
# preencher alguns dados faltantes com a media das outras estacoes
m = which(is.na(d$tempmin))
for (i in m) d$tempmin[i]<-(mean(d$tempmin[d$SE==d$SE[i]],na.rm=TRUE))
m = which(is.na(d$tempmin))
```

Alerta por APS em 4 niveis
-------------

**Verde (atividade baixa)** 
- se temperatura < 22 graus por 3 semanas 
- se atividade de tweet for normal (nao aumentada)
- ausencia de transmissao sustentada
- se incidencia < 100:100.000

**Amarelo (Alerta)**
- se temperatura > 22C por mais de 3 semanas
- se atividade de tweet aumentar

**Laranja (Transmissao sustentada)**
- se numero reprodutivo >1, por 3 semanas

**Vermelho (atividade alta)**
- se incidencia > 100:100.000

```{r echo=FALSE}
# data.frame para colocar os resultados
SE<-d$SE[d$APS=="AP1"]
d2 <- expand.grid(SE=SE,APS=listaAPS)
d2<-merge(d2,d[,c("SE","APS","data","tweets","estacao","casos","casosm","tempmin")],by=c("SE","APS"))
# agregar dados de populacao (cuidado, desorganiza tudo!)
pop<-read.csv(file="../tabelas/populacao2010porAPS_RJ.csv")
d2<-merge(d2,pop)
d2<-d2[order(d2$APS,d2$SE),]
```


```{r echo=FALSE}
#AlertaCli = Alerta de Temperatura minima semanal > 22 graus por 3 semanas**

#Temperatura > Tcrit
detcli <- function(temp,tempcrit=22,lag=3){
    t1<-as.numeric(temp>tempcrit)
    le <- length(t1)
    ac <- t1[lag:le]
    for(i in 1:(lag-1)) ac <- ac+t1[(lag-i):(le-i)]
    c(rep(NA,(lag-1)),ac)
}

d2$alertaCli <- NA
for(i in 1:10) d2$alertaCli[which(d2$APS==listaAPS[i])] <-detcli(d2$tempmin[d2$APS==listaAPS[i]])
```


```{r echo=FALSE}
# Rtw = crescimento significativo de tweet na ultima semana (repete os valores para todas as APS)
d2$Rtw <-NA  # Rt do tweet
d2$ptw1 <-NA # Prob(Rt tweet >1)
d2$Rtwlr <-NA # lim inf IC Rt tweet
d2$Rtwur <-NA  # lim sup IC Rt tweet

for(i in 1:10) d2[d2$APS==listaAPS[i],c("Rtw","ptw1","Rtwlr","Rtwur")] <- Rt.beta(d2$tweets[d2$APS==listaAPS[i]])

# funcao que calcula o indicador pr(Rt >1) >pcrit (default pcrit=0.95, lag=3)  # serve tanto para Rt de tweet como para casos

Rtgreat1 <- function(p1,pcrit=0.8,lag=0){
    t1<-as.numeric(p1>pcrit)
    ac<-t1
    if (lag>0) {
          le <- length(t1)
          ini <- (lag+1)
          ac <- t1[ini:le]
          for(i in 1:(ini-1)) ac <- ac+t1[(ini-i):(le-i)]
          ac<-c(rep(NA,(ini-1)),ac)
          }
    ac
}


# Rt(tweet) > 1 se Pr>0.9 
for(i in 1:10) d2$twgreat1[d2$APS==listaAPS[i]] <-Rtgreat1(d2$ptw1[d2$APS==listaAPS[i]],pcrit=0.90,lag=0)

# alertaRtweet = acumulado de Rt>1 por 3 vezes
for(i in 1:10) d2$alertaRtweet[d2$APS==listaAPS[i]] <-Rtgreat1(d2$ptw1[d2$APS==listaAPS[i]],pcrit=0.90,lag=3)
```


```{r echo=FALSE}
# calculo do Rt de dengue**

d2$Rt <-NA
d2$pRt1 <-NA
d2$Rtlr <-NA
d2$Rtur <-NA

for(i in 1:10) d2[d2$APS==listaAPS[i],c("Rt","pRt1","Rtlr","Rtur")] <- Rt.beta((d2$casosm[d2$APS==listaAPS[i]]))

#  imputa os P(Rt) faltantes com p(Rtw)
d2$pRti <- d2$pRt1
d2$pRti[is.na(d2$pRt1)]<-d2$ptw1[is.na(d2$pRt1)]
#d2$Rti <- d2$Rt1
#d2$Rti[is.na(d2$Rt)]<-d2$Rtw[is.na(d2$Rt)]


# Rt(dengue) > 1 se Pr>0.8 
for(i in 1:10) d2$Rtgreat1[d2$APS==listaAPS[i]] <-Rtgreat1(d2$pRti[d2$APS==listaAPS[i]],pcrit=0.90,lag=0)

# alertaRt = acumulado de Rt>1 por 3 vezes
for(i in 1:10) d2$alertaRt[d2$APS==listaAPS[i]] <-Rtgreat1(d2$pRti[d2$APS==listaAPS[i]],pcrit=0.90,lag=3)
```

```{r  echo=FALSE}
# Grafico de Rt(dengue). 
#par(mfrow=c(2,5),mar=c(3,2,1,1))
#for (j in 1:10) {
#      plot(231:251,d2$Rtlr[d2$APS==listaAPS[j]][231:251],lty=1,ylim=range(0,3),xlab="",ylab="Rt",axes=FALSE,type="l")
#      
#      polygon(c(231:251,251:231),c(d2$Rtlr[d2$APS==listaAPS[j]][231:251],rev(d2$Rtur[d2$APS==listaAPS[j]][231:251])),col="grey")
#      axis(2)
#      mtext(listaAPS[(j)],cex=0.8,line=-1)
#      box()
#      abline(h=0.9,col=2,lwd=3)
#      }
```


```{r echo=FALSE}
# Casos:
# onde houver dados faltantes, completar calculando o valor esperado considerando a tendencia de variacao das ultimas 3 semanas.
# Isso é, calcula a média de variacao (Rt) das ultimas 3 semanas e multiplica pelo valor observado de casos. 

fillCasos <- function(casos, Rt){
  casos_est <- casos
  n <- which(is.na(casos_est))
  if(length(n)>0) casos_est[n]<-casos[(n-2)]*mean(Rt[(n-2)],na.rm=TRUE)
  casos_est
  }
# print("mensagem de erro aqui - verificar")
d2$casos_est<-NA
for(i in 1:10) d2$casos_est[d2$APS==listaAPS[i]]<-fillCasos((d2$casos[d2$APS==listaAPS[i]]),
                                                            d2$Rt[d2$APS==listaAPS[i]])
d2$inc <- d2$casos_est/d2$Pop2010*100000
d2$alertaCasos <- as.numeric(d2$inc>100)

```


Resultado
---------

**Legenda:**
- SE : semana epidemiologica
- data: data de inicio da SE
- APS: area programatica da saude
- tempmin: media das temperaturas minimas da semana
- casos_est: numero de casos estimados na semana (3)
- inc: casos por 100.000 habitantes
- alertaClima = 1, se temperatura > 22C por mais de 3 semanas
- alertaTweet = 1, se Tweet com tendencia de aumento 
- alertaTransmissao = 1, se casos com tendencia de aumento
- alertaCasos = 1, se Incidencia > 100 por 100 mil

 

```{r echo=FALSE}

le = length(d2$tempmin[d2$APS==listaAPS[1]])

def.cor<-function(d2v){
# d2v = dados de uma ap
      # 1 = verde, 2=amarelo, 3 =laranja, 4 = vermelho
      les = dim(d2v)[1]
      d2v$cor <-NA
      d2v$cor[intersect(6:les,which(d2v$alertaCli<3 & d2v$alertaRtweet<3 & d2v$alertaRt<3 & d2v$alertaCasos==0))]<-1
      d2v$cor[intersect(6:les,which(d2v$alertaCli>=3 | d2v$alertaRtweet>=3))]<-2
      d2v$cor[intersect(6:les,which(d2v$alertaRt>=3))]<-3
      d2v$cor[intersect(6:les,which(d2v$alertaRt>=3)+1)]<-3 # inercia para desligar
      d2v$cor[intersect(6:les,which(d2v$alertaRt>=3)+2)]<-3 # inercia para desligar
      d2v$cor[intersect(6:les,which(d2v$alertaRt>=3)+3)]<-3 # inercia para desligar
      d2v$cor[intersect(6:les,which(d2v$alertaCasos==1))]<-4
      d2v$cor[intersect(6:les,which(d2v$alertaCasos==1)+1)]<-4  # inercia para desligar
      d2v$cor[intersect(6:les,which(d2v$alertaCasos==1)+2)]<-4   # inercia para desligar
      d2v$cor[intersect(6:les,which(d2v$alertaCasos==1)+3)]<-4
      d2v
}

d2$cor<-NA
for(i in 1:10) d2[d2$APS==listaAPS[i],]<-def.cor(d2[d2$APS==listaAPS[i],])

plot.alerta<-function(ap){
      par(mai=c(0,0,0,0),mar=c(4,1,1,1))
      d2v <- subset(d2,APS==ap)[52:le,]
      les = dim(d2v)[1]
      plot(1:les,d2v$casos,type="l",axes=FALSE,ylab="",xlab="")
      abline(v=which(d2v$alertaCli<3 & d2v$alertaRtweet<3 & d2v$alertaRt<3 & d2v$alertaCasos==0),
             col="darkgreen",lwd=2)
      abline(v=which(d2v$alertaCli>=3 | d2v$alertaRtweet>=3),col="yellow",lwd=2)
      vl = which(d2v$alertaRt>=3)
      abline(v=vl,col="orange",lwd=2)
      abline(v=(vl+1),col="orange",lwd=2)
      abline(v=(vl+2),col="orange",lwd=2)
      abline(v=(vl+3),col="orange",lwd=2)
      lines(1:les,d2v$casos)
      v=which(d2v$alertaCasos==1)
      abline(v=v,col="red",pch=16,lwd=2)
      abline(v=(v+1),col="red",pch=16,lwd=2)
      abline(v=(v+2),col="red",pch=16,lwd=2)
      title(as.character(ap),cex=1.4)
      axis(2)
      axis(1,at=rev(seq(les,1,by=-16)),labels=d2v$SE[rev(seq(les,1,by=-16))],las=2,cex=0.3)
      lines(1:les,d2v$casos,lwd=2)
}

plot.alerta2<-function(ap){
      par(mai=c(0,0,0,0),mar=c(4,1,1,1))
      d2v <- subset(d2,APS==ap)[52:le,]
      les = dim(d2v)[1]
      plot(1:les,d2v$casos,type="l",axes=FALSE,ylab="",xlab="")
      abline(v=which(d2v$cor==1),col="darkgreen",lwd=2)
      abline(v=which(d2v$cor==2),col="yellow",lwd=2)
      abline(v=which(d2v$cor==3),col="orange",lwd=2)
      abline(v=which(d2v$cor==4),col="red",lwd=2)
      title(as.character(ap),cex=1.4)
      axis(2)
      axis(1,at=rev(seq(les,1,by=-16)),labels=d2v$SE[rev(seq(les,1,by=-16))],las=2,cex=0.3)
      lines(1:les,d2v$casos,lwd=2)
}

# codificacao para o relatorio
d2$alertaTweet <- ifelse(d2$alertaRtweet>=3,1,0)
d2$alertaClima <- ifelse(d2$alertaCli>=3,1,0)
d2$alertaTransmissao <- ifelse(d2$alertaRt>=3,1,0)
d2$nivel<-"nulo"
d2$nivel[d2$cor==1]<-"verde"
d2$nivel[d2$cor==2]<-"amarelo"
d2$nivel[d2$cor==3]<-"laranja"
d2$nivel[d2$cor==4]<-"vermelho"

par(mfrow=c(1,1))
for(i in 1:10) {
      print(as.character(listaAPS[i]))
      print(tail(d2[d2$APS==listaAPS[i],c("SE","data","APS","tempmin","casos_est","inc","alertaClima","alertaTweet","alertaTransmissao","alertaCasos","nivel")],n=8))
      plot.alerta2(listaAPS[i])
}


#tiff("alerta.tif",res=200,compression = "lzw",width = 22,height = 15,units="cm")
#  layout(matrix(1:10,nrow = 2),widths = rep(lcm(4),5),heights = rep(lcm(7),2))
#  for(i in 1:10) plot.alerta2(listaAPS[i])
#dev.off()

#par(mfrow=c(1,1),mar=c(4,4,2,2))
#plot.alerta2(listaAPS[3])

#png("alerta.png",res=200,width = 22,height = 15,units="cm")
#  layout(matrix(1:10,nrow = 2),widths = rep(lcm(4),5),heights = rep(lcm(7),2))
#  for(i in 1:10) plot.alerta2(listaAPS[i])
#dev.off()

```

```{r echo=FALSE}

# graficos extras
#plot(d2$Rtw[(2870-20):2870],type="l",ylim=c(0,2),ylab="Rt(tweets)",xlab="últimas semanas")
#lines(d2$Rtwlr[(2870-20):2870],type="l",lty=2)
#lines(d2$Rtwur[(2870-20):2870],type="l",lty=2)
#abline(h=1,col=2)


```




```{r echo=FALSE}
#Primeiro, cortar a parte final que nao tenha os 3 alertas:
      
#d2$test<- with(d4, alertaRt1+alertaTemp)
#df <- d4[is.na(d4$test)==FALSE,c("SE","APS","casos","tweets","temp","Rt","casos_est","temp_crit","casos_crit","alertaRt1","alertaTemp","alertaCasos")]
```

```{r echo=FALSE}
outputfile = paste("../alerta/alertaAPS_",max(d2$SE),".csv",sep="")
```

```{r echo=FALSE}
write.table(d2,file=outputfile,row.names=FALSE,sep=",")
```



Notas
-----
- (1) Os dados do sinan mais recentes ainda nao foram totalmente digitados. Estimamos o numero esperado de casos
notificados considerando o tempo ate os casos serem digitados.
- (2) Os dados de tweets sao gerados pelo Observatorio de Dengue (UFMG). Os tweets sao processados para exclusao de informes e outros temas relacionados a dengue
- (3) Algumas vezes, os casos da ultima semana ainda nao estao disponiveis, nesse caso, usa-se uma estimacao com base na tendencia de variacao da serie 

Creditos
------
Esse e um projeto desenvolvido em parceria pela Fiocruz, FGV e Prefeitura do Rio de Janeiro, com apoio da SVS/MS

Mais detalhes, ver: www.dengue.mat.br
